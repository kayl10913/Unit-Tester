{"ast":null,"code":"// AI Service for generating unit tests\n// In a real application, this would connect to OpenAI, Claude, or similar AI services\n\nexport const generateTestsWithAI = async (sourceCode, testFramework, coverage) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));\n\n  // Analyze the source code to extract functions and classes\n  const functions = extractFunctions(sourceCode);\n  const classes = extractClasses(sourceCode);\n\n  // Generate tests based on the framework and coverage level\n  let tests = '';\n  switch (testFramework) {\n    case 'jest':\n      tests = generateJestTests(functions, classes, coverage);\n      break;\n    case 'mocha':\n      tests = generateMochaTests(functions, classes, coverage);\n      break;\n    case 'jasmine':\n      tests = generateJasmineTests(functions, classes, coverage);\n      break;\n    default:\n      tests = generateJestTests(functions, classes, coverage);\n  }\n  return tests;\n};\nconst extractFunctions = code => {\n  const functionRegex = /function\\s+(\\w+)\\s*\\([^)]*\\)\\s*\\{/g;\n  const arrowFunctionRegex = /const\\s+(\\w+)\\s*=\\s*\\([^)]*\\)\\s*=>/g;\n  const functions = [];\n  let match;\n  while ((match = functionRegex.exec(code)) !== null) {\n    functions.push({\n      name: match[1],\n      type: 'function',\n      line: code.substring(0, match.index).split('\\n').length\n    });\n  }\n  while ((match = arrowFunctionRegex.exec(code)) !== null) {\n    functions.push({\n      name: match[1],\n      type: 'arrowFunction',\n      line: code.substring(0, match.index).split('\\n').length\n    });\n  }\n  return functions;\n};\nconst extractClasses = code => {\n  const classRegex = /class\\s+(\\w+)/g;\n  const classes = [];\n  let match;\n  while ((match = classRegex.exec(code)) !== null) {\n    classes.push({\n      name: match[1],\n      type: 'class',\n      line: code.substring(0, match.index).split('\\n').length\n    });\n  }\n  return classes;\n};\nconst generateJestTests = (functions, classes, coverage) => {\n  let tests = `const { calculateSum, Calculator } = require('./source-code');\n\ndescribe('calculateSum function', () => {\n  test('should add two positive numbers correctly', () => {\n    expect(calculateSum(2, 3)).toBe(5);\n    expect(calculateSum(10, 20)).toBe(30);\n    expect(calculateSum(0, 0)).toBe(0);\n  });\n\n  test('should add negative numbers correctly', () => {\n    expect(calculateSum(-2, -3)).toBe(-5);\n    expect(calculateSum(-10, 20)).toBe(10);\n    expect(calculateSum(5, -3)).toBe(2);\n  });\n\n  test('should handle decimal numbers', () => {\n    expect(calculateSum(2.5, 3.5)).toBe(6);\n    expect(calculateSum(0.1, 0.2)).toBeCloseTo(0.3);\n  });\n\n  test('should throw error for non-numeric inputs', () => {\n    expect(() => calculateSum('2', 3)).toThrow('Both arguments must be numbers');\n    expect(() => calculateSum(2, '3')).toThrow('Both arguments must be numbers');\n    expect(() => calculateSum(null, 3)).toThrow('Both arguments must be numbers');\n    expect(() => calculateSum(undefined, 3)).toThrow('Both arguments must be numbers');\n  });\n\n  test('should throw error for missing arguments', () => {\n    expect(() => calculateSum(2)).toThrow();\n    expect(() => calculateSum()).toThrow();\n  });\n});\n\ndescribe('Calculator class', () => {\n  let calculator;\n\n  beforeEach(() => {\n    calculator = new Calculator();\n  });\n\n  describe('constructor', () => {\n    test('should initialize with empty history', () => {\n      expect(calculator.history).toEqual([]);\n    });\n  });\n\n  describe('add method', () => {\n    test('should add two numbers and return result', () => {\n      const result = calculator.add(5, 3);\n      expect(result).toBe(8);\n    });\n\n    test('should add numbers and store in history', () => {\n      calculator.add(5, 3);\n      expect(calculator.history).toHaveLength(1);\n      expect(calculator.history[0]).toEqual({\n        operation: 'add',\n        a: 5,\n        b: 3,\n        result: 8\n      });\n    });\n\n    test('should accumulate history for multiple operations', () => {\n      calculator.add(5, 3);\n      calculator.add(10, 20);\n      calculator.add(-5, 5);\n\n      expect(calculator.history).toHaveLength(3);\n      expect(calculator.history[0].result).toBe(8);\n      expect(calculator.history[1].result).toBe(30);\n      expect(calculator.history[2].result).toBe(0);\n    });\n\n    test('should throw error for invalid inputs', () => {\n      expect(() => calculator.add('5', 3)).toThrow('Both arguments must be numbers');\n      expect(() => calculator.add(5, '3')).toThrow('Both arguments must be numbers');\n    });\n  });\n\n  describe('getHistory method', () => {\n    test('should return empty array for new calculator', () => {\n      expect(calculator.getHistory()).toEqual([]);\n    });\n\n    test('should return history after operations', () => {\n      calculator.add(5, 3);\n      calculator.add(10, 20);\n\n      const history = calculator.getHistory();\n      expect(history).toHaveLength(2);\n      expect(history[0].operation).toBe('add');\n      expect(history[1].operation).toBe('add');\n    });\n\n    test('should return copy of history, not reference', () => {\n      calculator.add(5, 3);\n      const history1 = calculator.getHistory();\n      const history2 = calculator.getHistory();\n\n      expect(history1).not.toBe(history2);\n      expect(history1).toEqual(history2);\n    });\n  });\n});\n\n${coverage === 'comprehensive' ? `\n// Additional edge case tests for comprehensive coverage\ndescribe('Edge Cases and Error Handling', () => {\n  test('should handle very large numbers', () => {\n    const largeNumber = Number.MAX_SAFE_INTEGER;\n    expect(calculateSum(largeNumber, 1)).toBe(largeNumber + 1);\n  });\n\n  test('should handle very small numbers', () => {\n    const smallNumber = Number.MIN_SAFE_INTEGER;\n    expect(calculateSum(smallNumber, -1)).toBe(smallNumber - 1);\n  });\n\n  test('should handle Infinity values', () => {\n    expect(calculateSum(Infinity, 5)).toBe(Infinity);\n    expect(calculateSum(-Infinity, 5)).toBe(-Infinity);\n  });\n\n  test('should handle NaN values', () => {\n    expect(() => calculateSum(NaN, 5)).toThrow('Both arguments must be numbers');\n    expect(() => calculateSum(5, NaN)).toThrow('Both arguments must be numbers');\n  });\n});\n` : ''}\n`;\n  return tests;\n};\nconst generateMochaTests = (functions, classes, coverage) => {\n  return `const { expect } = require('chai');\nconst { calculateSum, Calculator } = require('./source-code');\n\ndescribe('calculateSum function', () => {\n  it('should add two positive numbers correctly', () => {\n    expect(calculateSum(2, 3)).to.equal(5);\n    expect(calculateSum(10, 20)).to.equal(30);\n  });\n\n  it('should throw error for non-numeric inputs', () => {\n    expect(() => calculateSum('2', 3)).to.throw('Both arguments must be numbers');\n  });\n});\n\ndescribe('Calculator class', () => {\n  let calculator;\n\n  beforeEach(() => {\n    calculator = new Calculator();\n  });\n\n  it('should add numbers correctly', () => {\n    const result = calculator.add(5, 3);\n    expect(result).to.equal(8);\n  });\n});`;\n};\nconst generateJasmineTests = (functions, classes, coverage) => {\n  return `describe('calculateSum function', () => {\n  it('should add two positive numbers correctly', () => {\n    expect(calculateSum(2, 3)).toBe(5);\n    expect(calculateSum(10, 20)).toBe(30);\n  });\n\n  it('should throw error for non-numeric inputs', () => {\n    expect(() => calculateSum('2', 3)).toThrow('Both arguments must be numbers');\n  });\n});\n\ndescribe('Calculator class', () => {\n  let calculator;\n\n  beforeEach(() => {\n    calculator = new Calculator();\n  });\n\n  it('should add numbers correctly', () => {\n    const result = calculator.add(5, 3);\n    expect(result).toBe(8);\n  });\n});`;\n};","map":{"version":3,"names":["generateTestsWithAI","sourceCode","testFramework","coverage","Promise","resolve","setTimeout","Math","random","functions","extractFunctions","classes","extractClasses","tests","generateJestTests","generateMochaTests","generateJasmineTests","code","functionRegex","arrowFunctionRegex","match","exec","push","name","type","line","substring","index","split","length","classRegex"],"sources":["C:/Users/USER/OneDrive/Documents/kuding/Unit Testing Generator/src/services/aiService.js"],"sourcesContent":["// AI Service for generating unit tests\r\n// In a real application, this would connect to OpenAI, Claude, or similar AI services\r\n\r\nexport const generateTestsWithAI = async (sourceCode, testFramework, coverage) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));\r\n\r\n  // Analyze the source code to extract functions and classes\r\n  const functions = extractFunctions(sourceCode);\r\n  const classes = extractClasses(sourceCode);\r\n\r\n  // Generate tests based on the framework and coverage level\r\n  let tests = '';\r\n  \r\n  switch (testFramework) {\r\n    case 'jest':\r\n      tests = generateJestTests(functions, classes, coverage);\r\n      break;\r\n    case 'mocha':\r\n      tests = generateMochaTests(functions, classes, coverage);\r\n      break;\r\n    case 'jasmine':\r\n      tests = generateJasmineTests(functions, classes, coverage);\r\n      break;\r\n    default:\r\n      tests = generateJestTests(functions, classes, coverage);\r\n  }\r\n\r\n  return tests;\r\n};\r\n\r\nconst extractFunctions = (code) => {\r\n  const functionRegex = /function\\s+(\\w+)\\s*\\([^)]*\\)\\s*\\{/g;\r\n  const arrowFunctionRegex = /const\\s+(\\w+)\\s*=\\s*\\([^)]*\\)\\s*=>/g;\r\n  const functions = [];\r\n\r\n  let match;\r\n  while ((match = functionRegex.exec(code)) !== null) {\r\n    functions.push({\r\n      name: match[1],\r\n      type: 'function',\r\n      line: code.substring(0, match.index).split('\\n').length\r\n    });\r\n  }\r\n\r\n  while ((match = arrowFunctionRegex.exec(code)) !== null) {\r\n    functions.push({\r\n      name: match[1],\r\n      type: 'arrowFunction',\r\n      line: code.substring(0, match.index).split('\\n').length\r\n    });\r\n  }\r\n\r\n  return functions;\r\n};\r\n\r\nconst extractClasses = (code) => {\r\n  const classRegex = /class\\s+(\\w+)/g;\r\n  const classes = [];\r\n\r\n  let match;\r\n  while ((match = classRegex.exec(code)) !== null) {\r\n    classes.push({\r\n      name: match[1],\r\n      type: 'class',\r\n      line: code.substring(0, match.index).split('\\n').length\r\n    });\r\n  }\r\n\r\n  return classes;\r\n};\r\n\r\nconst generateJestTests = (functions, classes, coverage) => {\r\n  let tests = `const { calculateSum, Calculator } = require('./source-code');\r\n\r\ndescribe('calculateSum function', () => {\r\n  test('should add two positive numbers correctly', () => {\r\n    expect(calculateSum(2, 3)).toBe(5);\r\n    expect(calculateSum(10, 20)).toBe(30);\r\n    expect(calculateSum(0, 0)).toBe(0);\r\n  });\r\n\r\n  test('should add negative numbers correctly', () => {\r\n    expect(calculateSum(-2, -3)).toBe(-5);\r\n    expect(calculateSum(-10, 20)).toBe(10);\r\n    expect(calculateSum(5, -3)).toBe(2);\r\n  });\r\n\r\n  test('should handle decimal numbers', () => {\r\n    expect(calculateSum(2.5, 3.5)).toBe(6);\r\n    expect(calculateSum(0.1, 0.2)).toBeCloseTo(0.3);\r\n  });\r\n\r\n  test('should throw error for non-numeric inputs', () => {\r\n    expect(() => calculateSum('2', 3)).toThrow('Both arguments must be numbers');\r\n    expect(() => calculateSum(2, '3')).toThrow('Both arguments must be numbers');\r\n    expect(() => calculateSum(null, 3)).toThrow('Both arguments must be numbers');\r\n    expect(() => calculateSum(undefined, 3)).toThrow('Both arguments must be numbers');\r\n  });\r\n\r\n  test('should throw error for missing arguments', () => {\r\n    expect(() => calculateSum(2)).toThrow();\r\n    expect(() => calculateSum()).toThrow();\r\n  });\r\n});\r\n\r\ndescribe('Calculator class', () => {\r\n  let calculator;\r\n\r\n  beforeEach(() => {\r\n    calculator = new Calculator();\r\n  });\r\n\r\n  describe('constructor', () => {\r\n    test('should initialize with empty history', () => {\r\n      expect(calculator.history).toEqual([]);\r\n    });\r\n  });\r\n\r\n  describe('add method', () => {\r\n    test('should add two numbers and return result', () => {\r\n      const result = calculator.add(5, 3);\r\n      expect(result).toBe(8);\r\n    });\r\n\r\n    test('should add numbers and store in history', () => {\r\n      calculator.add(5, 3);\r\n      expect(calculator.history).toHaveLength(1);\r\n      expect(calculator.history[0]).toEqual({\r\n        operation: 'add',\r\n        a: 5,\r\n        b: 3,\r\n        result: 8\r\n      });\r\n    });\r\n\r\n    test('should accumulate history for multiple operations', () => {\r\n      calculator.add(5, 3);\r\n      calculator.add(10, 20);\r\n      calculator.add(-5, 5);\r\n\r\n      expect(calculator.history).toHaveLength(3);\r\n      expect(calculator.history[0].result).toBe(8);\r\n      expect(calculator.history[1].result).toBe(30);\r\n      expect(calculator.history[2].result).toBe(0);\r\n    });\r\n\r\n    test('should throw error for invalid inputs', () => {\r\n      expect(() => calculator.add('5', 3)).toThrow('Both arguments must be numbers');\r\n      expect(() => calculator.add(5, '3')).toThrow('Both arguments must be numbers');\r\n    });\r\n  });\r\n\r\n  describe('getHistory method', () => {\r\n    test('should return empty array for new calculator', () => {\r\n      expect(calculator.getHistory()).toEqual([]);\r\n    });\r\n\r\n    test('should return history after operations', () => {\r\n      calculator.add(5, 3);\r\n      calculator.add(10, 20);\r\n\r\n      const history = calculator.getHistory();\r\n      expect(history).toHaveLength(2);\r\n      expect(history[0].operation).toBe('add');\r\n      expect(history[1].operation).toBe('add');\r\n    });\r\n\r\n    test('should return copy of history, not reference', () => {\r\n      calculator.add(5, 3);\r\n      const history1 = calculator.getHistory();\r\n      const history2 = calculator.getHistory();\r\n\r\n      expect(history1).not.toBe(history2);\r\n      expect(history1).toEqual(history2);\r\n    });\r\n  });\r\n});\r\n\r\n${coverage === 'comprehensive' ? `\r\n// Additional edge case tests for comprehensive coverage\r\ndescribe('Edge Cases and Error Handling', () => {\r\n  test('should handle very large numbers', () => {\r\n    const largeNumber = Number.MAX_SAFE_INTEGER;\r\n    expect(calculateSum(largeNumber, 1)).toBe(largeNumber + 1);\r\n  });\r\n\r\n  test('should handle very small numbers', () => {\r\n    const smallNumber = Number.MIN_SAFE_INTEGER;\r\n    expect(calculateSum(smallNumber, -1)).toBe(smallNumber - 1);\r\n  });\r\n\r\n  test('should handle Infinity values', () => {\r\n    expect(calculateSum(Infinity, 5)).toBe(Infinity);\r\n    expect(calculateSum(-Infinity, 5)).toBe(-Infinity);\r\n  });\r\n\r\n  test('should handle NaN values', () => {\r\n    expect(() => calculateSum(NaN, 5)).toThrow('Both arguments must be numbers');\r\n    expect(() => calculateSum(5, NaN)).toThrow('Both arguments must be numbers');\r\n  });\r\n});\r\n` : ''}\r\n`;\r\n\r\n  return tests;\r\n};\r\n\r\nconst generateMochaTests = (functions, classes, coverage) => {\r\n  return `const { expect } = require('chai');\r\nconst { calculateSum, Calculator } = require('./source-code');\r\n\r\ndescribe('calculateSum function', () => {\r\n  it('should add two positive numbers correctly', () => {\r\n    expect(calculateSum(2, 3)).to.equal(5);\r\n    expect(calculateSum(10, 20)).to.equal(30);\r\n  });\r\n\r\n  it('should throw error for non-numeric inputs', () => {\r\n    expect(() => calculateSum('2', 3)).to.throw('Both arguments must be numbers');\r\n  });\r\n});\r\n\r\ndescribe('Calculator class', () => {\r\n  let calculator;\r\n\r\n  beforeEach(() => {\r\n    calculator = new Calculator();\r\n  });\r\n\r\n  it('should add numbers correctly', () => {\r\n    const result = calculator.add(5, 3);\r\n    expect(result).to.equal(8);\r\n  });\r\n});`;\r\n};\r\n\r\nconst generateJasmineTests = (functions, classes, coverage) => {\r\n  return `describe('calculateSum function', () => {\r\n  it('should add two positive numbers correctly', () => {\r\n    expect(calculateSum(2, 3)).toBe(5);\r\n    expect(calculateSum(10, 20)).toBe(30);\r\n  });\r\n\r\n  it('should throw error for non-numeric inputs', () => {\r\n    expect(() => calculateSum('2', 3)).toThrow('Both arguments must be numbers');\r\n  });\r\n});\r\n\r\ndescribe('Calculator class', () => {\r\n  let calculator;\r\n\r\n  beforeEach(() => {\r\n    calculator = new Calculator();\r\n  });\r\n\r\n  it('should add numbers correctly', () => {\r\n    const result = calculator.add(5, 3);\r\n    expect(result).toBe(8);\r\n  });\r\n});`;\r\n};\r\n"],"mappings":"AAAA;AACA;;AAEA,OAAO,MAAMA,mBAAmB,GAAG,MAAAA,CAAOC,UAAU,EAAEC,aAAa,EAAEC,QAAQ,KAAK;EAChF;EACA,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,GAAGE,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;;EAE9E;EACA,MAAMC,SAAS,GAAGC,gBAAgB,CAACT,UAAU,CAAC;EAC9C,MAAMU,OAAO,GAAGC,cAAc,CAACX,UAAU,CAAC;;EAE1C;EACA,IAAIY,KAAK,GAAG,EAAE;EAEd,QAAQX,aAAa;IACnB,KAAK,MAAM;MACTW,KAAK,GAAGC,iBAAiB,CAACL,SAAS,EAAEE,OAAO,EAAER,QAAQ,CAAC;MACvD;IACF,KAAK,OAAO;MACVU,KAAK,GAAGE,kBAAkB,CAACN,SAAS,EAAEE,OAAO,EAAER,QAAQ,CAAC;MACxD;IACF,KAAK,SAAS;MACZU,KAAK,GAAGG,oBAAoB,CAACP,SAAS,EAAEE,OAAO,EAAER,QAAQ,CAAC;MAC1D;IACF;MACEU,KAAK,GAAGC,iBAAiB,CAACL,SAAS,EAAEE,OAAO,EAAER,QAAQ,CAAC;EAC3D;EAEA,OAAOU,KAAK;AACd,CAAC;AAED,MAAMH,gBAAgB,GAAIO,IAAI,IAAK;EACjC,MAAMC,aAAa,GAAG,oCAAoC;EAC1D,MAAMC,kBAAkB,GAAG,qCAAqC;EAChE,MAAMV,SAAS,GAAG,EAAE;EAEpB,IAAIW,KAAK;EACT,OAAO,CAACA,KAAK,GAAGF,aAAa,CAACG,IAAI,CAACJ,IAAI,CAAC,MAAM,IAAI,EAAE;IAClDR,SAAS,CAACa,IAAI,CAAC;MACbC,IAAI,EAAEH,KAAK,CAAC,CAAC,CAAC;MACdI,IAAI,EAAE,UAAU;MAChBC,IAAI,EAAER,IAAI,CAACS,SAAS,CAAC,CAAC,EAAEN,KAAK,CAACO,KAAK,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC,CAACC;IACnD,CAAC,CAAC;EACJ;EAEA,OAAO,CAACT,KAAK,GAAGD,kBAAkB,CAACE,IAAI,CAACJ,IAAI,CAAC,MAAM,IAAI,EAAE;IACvDR,SAAS,CAACa,IAAI,CAAC;MACbC,IAAI,EAAEH,KAAK,CAAC,CAAC,CAAC;MACdI,IAAI,EAAE,eAAe;MACrBC,IAAI,EAAER,IAAI,CAACS,SAAS,CAAC,CAAC,EAAEN,KAAK,CAACO,KAAK,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC,CAACC;IACnD,CAAC,CAAC;EACJ;EAEA,OAAOpB,SAAS;AAClB,CAAC;AAED,MAAMG,cAAc,GAAIK,IAAI,IAAK;EAC/B,MAAMa,UAAU,GAAG,gBAAgB;EACnC,MAAMnB,OAAO,GAAG,EAAE;EAElB,IAAIS,KAAK;EACT,OAAO,CAACA,KAAK,GAAGU,UAAU,CAACT,IAAI,CAACJ,IAAI,CAAC,MAAM,IAAI,EAAE;IAC/CN,OAAO,CAACW,IAAI,CAAC;MACXC,IAAI,EAAEH,KAAK,CAAC,CAAC,CAAC;MACdI,IAAI,EAAE,OAAO;MACbC,IAAI,EAAER,IAAI,CAACS,SAAS,CAAC,CAAC,EAAEN,KAAK,CAACO,KAAK,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC,CAACC;IACnD,CAAC,CAAC;EACJ;EAEA,OAAOlB,OAAO;AAChB,CAAC;AAED,MAAMG,iBAAiB,GAAGA,CAACL,SAAS,EAAEE,OAAO,EAAER,QAAQ,KAAK;EAC1D,IAAIU,KAAK,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEV,QAAQ,KAAK,eAAe,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN,CAAC;EAEC,OAAOU,KAAK;AACd,CAAC;AAED,MAAME,kBAAkB,GAAGA,CAACN,SAAS,EAAEE,OAAO,EAAER,QAAQ,KAAK;EAC3D,OAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,CAAC;AAED,MAAMa,oBAAoB,GAAGA,CAACP,SAAS,EAAEE,OAAO,EAAER,QAAQ,KAAK;EAC7D,OAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}